<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/></head><body>	import <a href="http://org.lwjgl.input.Mouse">org.lwjgl.input.Mouse</a>;<br>import <a href="http://org.lwjgl.opengl.Display">org.lwjgl.opengl.Display</a>;<br><br>import <a href="http://com.badlogic.gdx.ApplicationListener">com.badlogic.gdx.ApplicationListener</a>;<br>import <a href="http://com.badlogic.gdx.Gdx">com.badlogic.gdx.Gdx</a>;<br>import <a href="http://com.badlogic.gdx.InputAdapter">com.badlogic.gdx.InputAdapter</a>;<br>import <a href="http://com.badlogic.gdx.backends.lwjgl.LwjglApplication">com.badlogic.gdx.backends.lwjgl.LwjglApplication</a>;<br>import <a href="http://com.badlogic.gdx.backends.lwjgl.LwjglApplicationConfiguration">com.badlogic.gdx.backends.lwjgl.LwjglApplicationConfiguration</a>;<br>import <a href="http://com.badlogic.gdx.graphics">com.badlogic.gdx.graphics</a>.GL10;<br>import <a href="http://com.badlogic.gdx.graphics.OrthographicCamera">com.badlogic.gdx.graphics.OrthographicCamera</a>;<br>import <a href="http://com.badlogic.gdx.graphics.Texture">com.badlogic.gdx.graphics.Texture</a>;<br>import <a href="http://com.badlogic.gdx.graphics.g2d.SpriteBatch">com.badlogic.gdx.graphics.g2d.SpriteBatch</a>;<br>import <a href="http://com.badlogic.gdx.graphics.glutils.ShaderProgram">com.badlogic.gdx.graphics.glutils.ShaderProgram</a>;<br>import <a href="http://com.badlogic.gdx.math">com.badlogic.gdx.math</a>.Vector3;<br>import <a href="http://com.badlogic.gdx.utils.GdxRuntimeException">com.badlogic.gdx.utils.GdxRuntimeException</a>;<br><br>/**<br> * LibGDX port of ShaderLesson6, i.e. normal mapping in 2D games.<br> * @author davedes<br> */<br>public class ShaderLesson6 implements ApplicationListener {<br>&nbsp; <br>	<br>	public static void main(String[] args) {<br>		LwjglApplicationConfiguration cfg = new LwjglApplicationConfiguration();<br>		cfg.useGL20 = true;<br>		<a href="http://cfg.width">cfg.width</a> = <a href="tel:640">640</a>;<br>		<a href="http://cfg.height">cfg.height</a> = <a href="tel:480">480</a>;<br>		<a href="http://cfg.resizable">cfg.resizable</a> = false;<br>		new LwjglApplication(new ShaderLesson6(), cfg);<br>	}<br>	<br>	Texture rock, rockNormals;<br>	<br>	SpriteBatch batch;<br>	OrthographicCamera cam;<br>	<br>	ShaderProgram shader;<br><br>	//our constants...<br>	public static final float DEFAULT_LIGHT_Z = <a href="tel:0.075">0.075</a>f;<br>	public static final float AMBIENT_INTENSITY = <a href="tel:0.2">0.2</a>f;<br>	public static final float LIGHT_INTENSITY = 1f;<br>	<br>	public static final Vector3 LIGHT_POS = new Vector3(0f,0f,DEFAULT_LIGHT_Z);<br>	<br>	//Light RGB and intensity (alpha)<br>	public static final Vector3 LIGHT_COLOR = new Vector3(1f, <a href="tel:0.8">0.8</a>f, <a href="tel:0.6">0.6</a>f);<br><br>	//Ambient RGB and intensity (alpha)<br>	public static final Vector3 AMBIENT_COLOR = new Vector3(<a href="tel:0.6">0.6</a>f, <a href="tel:0.6">0.6</a>f, 1f);<br><br>	//Attenuation coefficients for light falloff<br>	public static final Vector3 FALLOFF = new Vector3(.4f, 3f, 20f);<br>	<br>	<br>	final String VERT =&nbsp; <br>			"attribute vec4 "+ShaderProgram.POSITION_ATTRIBUTE+";\n" +<br>			"attribute vec4 "+ShaderProgram.COLOR_ATTRIBUTE+";\n" +<br>			"attribute vec2 "+ShaderProgram.TEXCOORD_ATTRIBUTE+"0;\n" +<br>			<br>			"uniform mat4 u_projTrans;\n" + <br>			" \n" + <br>			"varying vec4 vColor;\n" +<br>			"varying vec2 vTexCoord;\n" +<br>			<br>			"void main() {\n" +&nbsp; <br>			"	vColor = "+ShaderProgram.COLOR_ATTRIBUTE+";\n" +<br>			"	vTexCoord = "+ShaderProgram.TEXCOORD_ATTRIBUTE+"0;\n" +<br>			"	gl_Position =&nbsp; u_projTrans * " + ShaderProgram.POSITION_ATTRIBUTE + ";\n" +<br>			"}";<br>	<br>	//no changes except for LOWP for color values<br>	//we would store this in a file for increased readability<br>	final String FRAG = <br>			//GL ES specific stuff<br>			&nbsp; "#ifdef GL_ES\n" //<br>			+ "#define LOWP lowp\n" //<br>			+ "precision mediump float;\n" //<br>			+ "#else\n" //<br>			+ "#define LOWP \n" //<br>			+ "#endif\n" + //<br>			"//attributes from vertex shader\n" + <br>			"varying LOWP vec4 vColor;\n" + <br>			"varying vec2 vTexCoord;\n" + <br>			"\n" + <br>			"//our texture samplers\n" + <br>			"uniform sampler2D u_texture;&nbsp;&nbsp; //diffuse map\n" + <br>			"uniform sampler2D u_normals;&nbsp;&nbsp; //normal map\n" + <br>			"\n" + <br>			"//values used for shading algorithm...\n" + <br>			"uniform vec2 Resolution;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //resolution of screen\n" + <br>			"uniform vec3 LightPos;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //light position, normalized\n" + <br>			"uniform LOWP vec4 LightColor;&nbsp;&nbsp;&nbsp; //light RGBA -- alpha is intensity\n" + <br>			"uniform LOWP vec4 AmbientColor;&nbsp; //ambient RGBA -- alpha is intensity \n" + <br>			"uniform vec3 Falloff;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //attenuation coefficients\n" + <br>			"\n" + <br>			"void main() {\n" + <br>			"	//RGBA of our diffuse color\n" + <br>			"	vec4 DiffuseColor = texture2D(u_texture, vTexCoord);\n" + <br>			"	\n" + <br>			"	//RGB of our normal map\n" + <br>			"	vec3 NormalMap = texture2D(u_normals, vTexCoord).rgb;\n" + <br>			"	\n" + <br>			"	//The delta position of light\n" + <br>			"	vec3 LightDir = vec3(<a href="http://LightPos.xy">LightPos.xy</a> - (<a href="http://gl_FragCoord.xy">gl_FragCoord.xy</a> / <a href="http://Resolution.xy">Resolution.xy</a>), LightPos.z);\n" + <br>			"	\n" + <br>			"	//Correct for aspect ratio\n" + <br>			"	LightDir.x *= Resolution.x / Resolution.y;\n" + <br>			"	\n" + <br>			"	//Determine distance (used for attenuation) BEFORE we normalize our LightDir\n" + <br>			"	float D = length(LightDir);\n" + <br>			"	\n" + <br>			"	//normalize our vectors\n" + <br>			"	vec3 N = normalize(NormalMap * <a href="tel:2.0 - 1.0">2.0 - 1.0</a>);\n" + <br>			"	vec3 L = normalize(LightDir);\n" + <br>			"	\n" + <br>			"	//Pre-multiply light color with intensity\n" + <br>			"	//Then perform \"N dot L\" to determine our diffuse term\n" + <br>			"	vec3 Diffuse = (<a href="http://LightColor.rgb">LightColor.rgb</a> * LightColor.a) * max(dot(N, L), <a href="tel:0.0">0.0</a>);\n" + <br>			"\n" + <br>			"	//pre-multiply ambient color with intensity\n" + <br>			"	vec3 Ambient = <a href="http://AmbientColor.rgb">AmbientColor.rgb</a> * AmbientColor.a;\n" + <br>			"	\n" + <br>			"	//calculate attenuation\n" + <br>			"	float Attenuation = <a href="tel:1.0">1.0</a> / ( Falloff.x + (Falloff.y*D) + (Falloff.z*D*D) );\n" + <br>			"	\n" + <br>			"	//the calculation which brings it all together\n" + <br>			"	vec3 Intensity = Ambient + Diffuse * Attenuation;\n" + <br>			"	vec3 FinalColor = <a href="http://DiffuseColor.rgb">DiffuseColor.rgb</a> * Intensity;\n" + <br>			"	gl_FragColor = vColor * vec4(FinalColor, DiffuseColor.a);\n" + <br>			"}";<br>	<br>	@Override<br>	public void create() {<br>		rock = new Texture(<a href="http://Gdx.files.internal">Gdx.files.internal</a>("data/<a href="http://rock.png">rock.png</a>"));<br>		rockNormals = new Texture(<a href="http://Gdx.files.internal">Gdx.files.internal</a>("data/<a href="http://rock_n.png">rock_n.png</a>"));<br>		<br>		<a href="http://ShaderProgram.pedantic">ShaderProgram.pedantic</a> = false;<br>		shader = new ShaderProgram(VERT, FRAG);<br>		//ensure it compiled<br>		if (!<a href="http://shader.isCompiled">shader.isCompiled</a>())<br>			throw new GdxRuntimeException("Could not compile shader: "+<a href="http://shader.getLog">shader.getLog</a>());<br>		//print any warnings<br>		if (<a href="http://shader.getLog">shader.getLog</a>().length()!=0)<br>			<a href="http://System.out.println">System.out.println</a>(<a href="http://shader.getLog">shader.getLog</a>());<br>		<br>		//setup default uniforms<br>		<a href="http://shader.begin">shader.begin</a>();<br><br>		//our normal map<br>		<a href="http://shader.setUniformi">shader.setUniformi</a>("u_normals", 1); //GL_TEXTURE1<br>		<br>		//light/ambient colors<br>		//LibGDX doesn't have Vector4 class at the moment, so we pass them individually...<br>		<a href="http://shader.setUniformf">shader.setUniformf</a>("LightColor", LIGHT_COLOR.x, LIGHT_COLOR.y, LIGHT_COLOR.z, LIGHT_INTENSITY);<br>		<a href="http://shader.setUniformf">shader.setUniformf</a>("AmbientColor", AMBIENT_COLOR.x, AMBIENT_COLOR.y, AMBIENT_COLOR.z, AMBIENT_INTENSITY);<br>		<a href="http://shader.setUniformf">shader.setUniformf</a>("Falloff", FALLOFF);<br>		<br>		//LibGDX likes us to end the shader program<br>		<a href="http://shader.end">shader.end</a>();<br>		<br>		batch = new SpriteBatch(<a href="tel:1000">1000</a>, shader);<br>		<a href="http://batch.setShader">batch.setShader</a>(shader);<br>		<br>		cam = new OrthographicCamera(<a href="http://Gdx.graphics.getWidth">Gdx.graphics.getWidth</a>(), <a href="http://Gdx.graphics.getHeight">Gdx.graphics.getHeight</a>());<br>		<a href="http://cam.setToOrtho">cam.setToOrtho</a>(false);<br>		<br>		//handle mouse wheel<br>		<a href="http://Gdx.input.setInputProcessor">Gdx.input.setInputProcessor</a>(new InputAdapter() {<br>			public boolean scrolled(int delta) {<br>				//LibGDX mouse wheel is inverted compared to lwjgl-basics<br>				LIGHT_POS.z = <a href="http://Math.max">Math.max</a>(0f, LIGHT_POS.z - (delta * <a href="tel:0.005">0.005</a>f));<br>				<a href="http://System.out.println">System.out.println</a>("New light Z: "+LIGHT_POS.z);<br>				return true;<br>			}<br>		});<br>	}<br><br>	@Override<br>	public void resize(int width, int height) {<br>		<a href="http://cam.setToOrtho">cam.setToOrtho</a>(false, width, height);<br>		<a href="http://batch.setProjectionMatrix">batch.setProjectionMatrix</a>(<a href="http://cam.combined">cam.combined</a>);<br>		<br>		<a href="http://shader.begin">shader.begin</a>();<br>		<a href="http://shader.setUniformf">shader.setUniformf</a>("Resolution", width, height);<br>		<a href="http://shader.end">shader.end</a>();<br>	}<br><br>	@Override<br>	public void render() {<br>		<a href="http://Gdx.gl.glClear">Gdx.gl.glClear</a>(GL10.GL_COLOR_BUFFER_BIT);<br>		<br>		//reset light Z<br>		if (<a href="http://Gdx.input.isTouched">Gdx.input.isTouched</a>()) {<br>			LIGHT_POS.z = DEFAULT_LIGHT_Z;<br>			<a href="http://System.out.println">System.out.println</a>("New light Z: "+LIGHT_POS.z);<br>		}<br>		<br>		<a href="http://batch.begin">batch.begin</a>();<br>		<br>		//shader will now be in use...<br>		<br>		//update light position, normalized to screen resolution<br>		float x = <a href="http://Mouse.getX">Mouse.getX</a>() / (float)<a href="http://Display.getWidth">Display.getWidth</a>();<br>		float y = <a href="http://Mouse.getY">Mouse.getY</a>() / (float)<a href="http://Display.getHeight">Display.getHeight</a>();<br>				<br>		LIGHT_POS.x = x;<br>		LIGHT_POS.y = y;<br>		<br>		//send a Vector4f to GLSL<br>		<a href="http://shader.setUniformf">shader.setUniformf</a>("LightPos", LIGHT_POS);<br>		<br>		//bind normal map to texture unit 1<br>		<a href="http://rockNormals.bind">rockNormals.bind</a>(1);<br>		<br>		//bind diffuse color to texture unit 0<br>		//important that we specify 0 otherwise we'll still be bound to glActiveTexture(GL_TEXTURE1)<br>		<a href="http://rock.bind">rock.bind</a>(0);<br>		<br>		//draw the texture unit 0 with our shader effect applied<br>		<a href="http://batch.draw">batch.draw</a>(rock, 0, 0);<br>		<br>		<a href="http://batch.end">batch.end</a>();<br>	}<br><br>	@Override<br>	public void pause() {<br>		<br>	}<br><br>	@Override<br>	public void resume() {<br>		<br>	}<br><br>	@Override<br>	public void dispose() {<br>		<a href="http://batch.dispose">batch.dispose</a>();<br>		<a href="http://rock.dispose">rock.dispose</a>();<br>		<a href="http://rockNormals.dispose">rockNormals.dispose</a>();<br>		<a href="http://shader.dispose">shader.dispose</a>();<br>	}	<br>}</body></html>